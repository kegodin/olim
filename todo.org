* Quasipotential Todo
** TODO Implement cost functions
   - [X] Rederive
   - [ ] First pass in Python
   - [ ] Copy eikonal cost funcs

* <2019-01-09 Wed>
  1. [X] Check that plots are fixed
  2. [X] Fix plotting on tessier (just run in ipython for now)
  3. [X] Get stats working again
  4. [X] Use stats as baseline to see where we're at with skipping
  5. [X] Run basic vs. olim6 on armitage & tessier

* <2019-01-10 Thu>
  1. [X] olim* direct solver tri skipping
  2. [X] Writeup: new skipping idea

* <2019-01-11 Fri>
  1. [X] Make sure all plots use figsize=(6.5, *) and font size = 8
  2. [X] Script: extract task % from profile data
  3. [X] Plot: task %
  4. [X] Combine and automate the previous two
  5. [ ] olimhu skipping
  6. [X] Writeup: "implementation stats"

* <2019-01-12 Sat>
  1. [X] Finish optimizing Lagrange multipliers
  2. [X] Use MATLAB to generate some tests for `should_skip'

* <2019-01-22 Tue>
  1. [X] SoA task

* General refactoring
  1. [X] Remove all instances of EIKONAL and replace with OLIM
  2. [X] Add vector class
  3. [-] Rewrite as much as possible in terms of vector class
     - [X] Add a `range' iterator to simplify loops and make them
       coordinate-free
     - [ ] Use vec for passing around U values and S values in updates
     - [ ] Convert solvers to receive vec values
     - [ ] Use SIMD to speed this up!!!
  4. [X] Add .cross to vec.hpp for olim3d_hu::init_crtp
  5. [ ] Simplify updates.tri.hpp... It's way more complicated than it
     needs to be... 330 lines where it should be around 100-150
  6. [X] Collapse marcher and marcher_3d into one class
  7. [ ] Some renaming
     - [ ] olim -> olim2
     - [ ] olim3d -> olim3
       - [ ] olim3d_bv -> ?
       - [ ] olim3d_hu -> ?
     - [ ] basic_marcher -> fmm2
     - [ ] basic_marcher_3d -> fmm3
     - [ ] lin_hat -> lin (possible?)
  8. [X] speed -> slowness
  9. [X] get_value -> get_U
  10. [X] T -> U everwhere
  11. [ ] Add T = template parameter for double/float
  12. [ ] Distinguish between indices
      - [ ] Add a `handle' type to distinguish the location of a node
        in the grid
      - [ ] Add a neighborhood index type to distinguish the location
        of a node in a neighborhood
  13. [ ] Remove second argument from `sqp_bary': i.e., use only one
      `x' argument which contains the initial iterate to begin and is
      overwritten with the optimum at the end. When we do this, we can
      also:
      - [ ] Have `sqp_bary' return its error code in an enum
      - [ ] Just take the updates::info<d> struct as a reference
        instead of separate parameters
  14. [ ] Don't actually need to store qr_wkspc in cost_functor...
  15. [ ] Reduce line count in tests using generic lambdas...
  16. [ ] Remove STL headers
  17. [X] Remove macros
      - [X] P*** macros -> b'***' literals
  18. [ ] Global p_fac -> pf
  19. [ ] Global s_fac -> sf
  20. [ ] Should probably remove `marcher::proxy' and just pass a
      pointer to marcher itself, since it can implement the interface
      that `proxy' needs to implement for compatibility with heap
  21. [X] Remove initializer_list use... See [[https://stackoverflow.com/questions/36265128/initialize-stdarray-by-parameter-pack-from-arbitrary-index][this]]
  22. [ ] Add a "SHOULD_ASSERT" macro
  23. [ ] Make a distinction between the `cost_funcs' module and the
      `quadrature' enum/type
  24. [ ] Remove all instances of `virtual'!
  25. [ ] See comment about constructors in `abstract_olim3d'
  26. [-] Combine basic_marcher and basic_marcher_3d
      - [X] name `fmm'
      - [X] specialize for 2d and 3d
      - [ ] add an algorithm for general dimension
  27. [ ] The problem with std::visit on OS X is that it might throw
      std::variant_bad_access, which I guess doesn't exist until
      10.14. One possible way around this is to turn off exceptions?
  28. [ ] some renaming:
      - [ ] add_bd/add_boundary -> add_src/add_source
        - [ ] also add a function which adds a boundary node and does
          corresponding changes to U and s apart from state
      - [ ] run -> solve
      - [ ] add step back in

* General optimization
  1. [ ] The octant optimization is worth doing: without it, we end up
     wasting time accessing `inds' and checking if the indices are
     equal to `parent'
  2. [ ] Remove `in_bounds' check by using a (n+2)^3 grid---this
     Actually does appear to take a significant amount of time...
     - [ ] Add a "barrier" state and just set the boundary to
       "barrier" to implement this without having to think too hard
       about it
     - [ ] Once we finish this, we should see about reducing the
       amount that we're converting back and forth between linear and
       Cartesian indices
  3. [ ] Reduce branching by replacing "if (nb[i]) {...}" with a
     precomputed array of indices to valid neighbors
  4. [ ] Split fac and non-fac update functions
  5. [ ] Try to get olim6_rhr to run as fast as basic_marcher_3d
     - currently pretty damn close... olim6_rhr is about 15% slower
  6. [ ] Speed up tests
     - [ ] unity build
  7. [ ] Try disabling exceptions
  8. [ ] Replace `malloc' and `new's with "operator new" (minimum
     number of includes and no unnecessary calling of ctors via new)
     - need to be careful about this---new can throw...
     - a combination of malloc and placement new might be the best way
       to go
  9. [ ] The generated bindings are quite large because we have to
     instantiate every possible OLIM. Can we get this size down by
     "factoring" the OLIM?
     - i.e., we have olimN_Q, where N is the neighborhood and Q is the
       quadrature rule
     - can we split this into two seperate classes, so that instead of
       having to stamp out olimN_Q for all N x Q, we could just stamp
       out a class for "N" and a class for "Q", for a total of N + Q
       class?
     - this wouldn't be a substantial redunction in the total number
       of classes, but my feeling is that the bloat is coming from,
       e.g., having to stamp out 18 versions of the cost_func stuff
       instead of just 3...
  10. [ ] Checking nb[i] >= 0 is almost surely going to be faster than
      checking if nb[i] != -1...

* Interface/FFI improvements
  1. [ ] Replace pybind11 with Cython
  2. [ ] Add a MATLAB interface
  3. [ ] Add a Julia interface

* Memory optimization
  1. [X] decrease size of state to a char
  2. [ ] value = 4/8 bytes (float/double)
  3. [ ] heap_pos = 2/4 bytes
  4. [ ] Optimize memory to the point that we can run 1025^3 jobs on a
     computer with 64GB of memory
  5. [X] Convert to SOA

* Remove `update' classes
  1. [ ] Getting to the point where probably the simplest thing is to
     just delete the "update" classes and move everything into the
     olim & olim3d classes as member functions...

* Numerical ideas
  1. [ ] Since triangle updates are so much cheaper than SQP updates,
     a better approach to solving unconstrained optimization problems
     might be to implement the following constrained algorithm:
     1) Do each triangle update + lagmults & skipping
     2) Do interior solve only if the above fails
     3) Could try a regular old Newton iteration for the interior solve...
     If we did this, we wouldn't need to do the fussy triangle
     skipping when we use the direct solver: we would only use it for
     the interior point case, since after solving the three triangle
     updates, we would know definitively if the optimum is in the
     interior
  2. [ ] Re-enable skipping and see if we can get any speedup
  3. [ ] Lag mults
     - [ ] Add initial lambda argument
     - [ ] Warm start using triangle update arglam
     - [ ] Check lagmults inside of tetra

# Local Variables:
# indent-tabs-mode: nil
# End:

* Things to tell Masha about
  - [ ] bitvector rewrite
  - [ ] skipping tetras
  - [ ] projected newton
  - [ ] show her a pathological case
* Masha's todo list
   1. "Suppose slowness is smooth or Lipschitz continuous. Show that
      than one can use hierarchical update rules for saving CPU time."
   2. "3D: hierarchical update vs complete update"
   3. "Smart mesh"
   4. "Smart mesh for 6 point update"
   5. "Predictive smart mesh"
* Writeups
  - [ ] algorithms
* New todo
  - [ ] Write an implementation of olim18 and olim26 that iterates over all valid tetrahedra
* New Newton's method (constrained) for tetrahedra
  - [X] finish prototyping new tetra newton in MATLAB
    - [X] get qpe working
    - [X] get qpi working
      - [X] fix case where minimum is in the interior and x0 is on the
        boundary
    - [X] replace quadprog with qpi in:
      - [X] F0_tetra_test.m
      - [X] F1_tetra_test.m
  - [X] minimize Rayleigh quotients to find lambda_min for Hessians
    - just need to do this by brute force since minimization <=>
      solving nonlinear equations for zero
  - [X] write C++ utility module for all this
    - [X] write qpe
    - [X] write qpi
    - [X] write sqp
    - [X] write tests
  - [-] replace old C++
    - [X] template version
      - [X] F0
        - [X] tri
        - [X] tetra
      - [X] F1
        - [X] tri
        - [X] tetra
    - [ ] general p0, p1, p2 version
      - [ ] F0
        - [ ] tri
        - [ ] tetra
      - [ ] F1
        - [ ] tri
        - [ ] tetra
  - [X] add general speed func test for olim4_rhr
  - [ ] add the rest of the 3d speed funcs and extend the tests to use
    them and iterate over them
    - also make an array of pairs of 2d/3d speed funcs for simpler iteration
  - [-] get all tests working
    - [ ] olim18_mp0.test.cpp
    - [ ] olim18_mp1.test.cpp
    - [ ] olim18_rhr.test.cpp
    - [ ] olim26_mp0.test.cpp
    - [ ] olim26_mp1.test.cpp
    - [ ] olim26_rhr.test.cpp
    - [ ] olim3d.test.cpp
    - [X] olim4_mp0.test.cpp
    - [X] olim4_mp1.test.cpp
    - [X] olim4_rhr.test.cpp
    - [X] olim6_mp0.test.cpp
    - [X] olim6_mp1.test.cpp
    - [X] olim6_rhr.test.cpp
    - [ ] olim8_mp0.test.cpp
    - [ ] olim8_mp1.test.cpp
    - [ ] olim8_rhr.test.cpp
    - [ ] update_rules.tetra_updates.test.cpp
    - [X] update_rules.tri_updates.test.cpp
  - [ ] consider removing speed estimators
  - [ ] get line_updates to conform with new template style
    (e.g. "degree" template parameter)
  - [ ] try nocedal & wright interpolation line search method
  - [ ] try golden section search
  - [ ] get olim to conditionally use moore marcher or neumann marcher
    depending on adj and diag bools
* Unconstrained method stuff
  once we get the constrained method working, we'll take a look at
  this---the stuff here doesn't make much sense for the constrained
  approach, since an optimized descent direction can't be used with
  SQP... and if we're doing the constrained updates, then we can't
  "skip" an update
  - [ ] check if we're using the simplified descent direction for F0
  - [ ] derive the simplified descent direction for F1
  - [ ] try exact step size for F0
  - [ ] derive exact step size for F1
  - [ ] skipping
    - [ ] F0
      - [ ] tri
      - [ ] tetra
    - [ ] F1
      - [ ] tri
      - [ ] tetra
* Collected from <2017-10-23 Mon>
  - [ ] fix dP vs dP' fuckup
  - [-] get rid of tetraXXX and replace with tetra<d0, d1, d2>
    - [X] initial rewrite
    - [ ] tetra122 as special case (template specialization)
  - [ ] write general 3D OLIM using template parameters for which
    "groups" of updates to do
  - [ ] test rewritten F1 in MATLAB
  - [ ] rewrite F1 using CTFE in C++
  - [ ] projected newton
    - [ ] test in MATLAB
      - [ ] F0
      - [ ] F1
  - [ ] skipping updates
    - [ ] test in MATLAB
      - [ ] F0
      - [ ] F1
  - [ ] make plot.py generate lots of plots
    - [ ] errors
      - [ ] 2D
      - [ ] 3D
    - [ ] timings
      - [ ] 2D
      - [ ] 3D
    - [ ] error slice
    - [ ] solution slice
  - [-] add "monotonically decreasing error" tests
    - [-] 2D
      - [X] default speed func
      - [ ] other speed funcs
    - [ ] 3D
      - [ ] default speed func
      - [ ] other speed funcs
  - [ ] templatized speed func test
    - [ ] 2D
      - [ ] is_symmetric
    - [ ] 3D
      - [ ] is_symmetric
  - [ ] large olim26_mp1 is more accurate than olim26_mp0/rhr---find this error
  - [ ] olim8 mp1 takes a long time on s5 and s9
  - [ ] randomize tetra newton lam0 to see if that effects "error
    dimples"
  - [ ] go through results from larger olim18mp1 and olim26mp1 and
    compare 'inf' results with MATLAB solution
  - [ ] add some randomized tests for tri and tetra updates to make
    sure that rhr and mp0 agree with mp1 when speed function is 1
  - [ ] writeup for mp1 tetra newton is wrong---is actually "rhr
    mp1"... maybe this is a valid method? fix, anyway
  - [ ] seems likely that the way i'm defining and passing speed
    functions in python (i.e. the way i'm using pybind11) is slowing
    things way down)---fix this
  - [ ] add tests for new mp1 stuff
  - [ ] i changed the implementation of mp1 tri newton so that it now
    solves the constrained problem, and there is no longer any
    difference between unconstrained and constrained mp1 tri
  - [ ] add 2d templatized test stuff
  - [ ] fix line num info in templatized tests (get it back)
  - [ ] speed_func -> scalar_field
  - [ ] olim_util.hpp -> olim_debug.hpp (or something)
  - [ ] add "exact" Newton for OLIM6/18
  - [ ] add constrained/unconstrained options for tetra solvers
  - [ ] remove olim18.defs.hpp
  - [ ] make olim8 and olim8hu use macros
  - [ ] use tagged dispatch to dispatch on algorithm
  - [ ] check difference in error between olim8_mp1 using fixed
    constrained and old method
  - [ ] use macro to capture tri update boilerplate (e.g. in mp1 tri
    updates)
* OLIM
  - [X] Get olim6_rhr_arma working in release mode (wtf?)
  - [X] Debug olim6_rhr_arma
  - [X] finite diff 3d tests:
    - [X] quadrant
    - [X] octant
    - [X] 2x2x3
    - [X] symmetry
  - [X] olim6 tests
    - [X] quadrant tests
    - [X] octant tests
    - [X] 2x2x3
    - [X] symmetry tests
  - [X] Rewrite olim18 using a loop
    - [X] initial rewrite
    - [X] quadrant tests
    - [X] octant tests
    - [X] 2x2x3
    - [X] symmetry tests
  - [X] Rewrite olim26 using a loop
    - [X] initial rewrite
    - [X] quadrant tests
    - [X] octant tests
    - [X] 2x2x3
    - [X] symmetry tests
  - [X] Go back and turn olim26 into the unconstrained algorithm
  - [X] Get OLIM6 working with speed functions
    - [X] Write tests to compare with basic3d
  - [X] use macros to simplify OLIM6/18/26 update calls (e.g. TETRA111UPDATE)
  - [ ] add default speed function to errors (in the same way as errors3d)
  - [ ] fix pernicious 3D OLIM bug
  - [ ] implement OLIM6/18/26 MP1
  - [ ] add the rest of the speed functions in 3D
  - [ ] large scale 3D tests
    - run large 3D errors and 3D timings test on computer at work or
      on cluster
    - do automatically for all different speed functions
    - TRY to get up to n = 1025
  - [ ] exact update for tetra111 and tetra222
  - [ ] make a template class encapsulating 3D tests
  - [ ] need to go through and rigorously separate "constrained"
    optimizers from "unconstrained" optimizers
  - [X] Make errors3d
  - [X] Make timings3d
  - [ ] Make sure each of olim6/18/26_rhr has:
    - [ ] a "constrained optimization" algorithm
    - [ ] an "unconstrained optimization" algorithm
  - [ ] Make sure each of olim4/8 has:
    - [ ] contrained implementation
    - [ ] unconstrained implementation
      where each are conditionally compiled using SFINAE depending on a
      compile-time constant belonging to the rootfinder
  - [X] Implement olim6/18/26 using nonlinear optimization
  - [X] Implement olim6/18/26 mp0
  - [ ] Hierarchical updates
  - [X] Make it possible to conditionally compile the adj updates in olim8
  - [ ] olim6/18/26 LUT
  - [ ] consolidate olim_util in olim_updates
  - [ ] implement olim4_mp1! (missed this...)
* Ideas
** Adaptive neighborhoods
   - Maybe there's some way of selecting between different OLIMks
     depending on the speed function or function values, so in a
     certain regime we could drop e.g. from OLIM8 to OLIM4 and speed
     the method up
** Higher order OLIM?
   - The "partially higher order" (2nd order) finite difference method
     does a 2nd order finite difference update when the nodes are
     available for it---we could extend this to OLIM straightforwardly
** Fast olim8_mp1 using exact Newton?
   - Can we do the olim8_mp1 update if we use an exact Newton line
     search?
** "Eikonal on a manifold"
   - Speed functions can be parametrized by the geodesic distance r,
     or they can be parametrized by the coordinates in the ambient
     space
     - In the former case, would it be necessary to first select an
       "origin" by placing a point somewhere on the manifold,
       computing the speed function, and then using that as input for
       the rest of the algorithm?
** Exact integration using MP0
   - Is it possible to integrate using MP0 exact if we use information
     about the speed function?
   - Could we then come up with a heuristic to integrate better for an
     unknown speed function?
** Regular mesh triangular updates
   - There are two types of "regular mesh triangular updates" (RMTUs)
     in 2D and three in 3D. It's easy to identify these with ways of
     choosing simplices embedded in a hybercube based on the Hamming
     norms of the vertices of the simplices. Are there n RMTUs in n
     dimensions? Is there an automatic procedure to extract them?
** FEM mesh generator (from class) + trimesh marcher
** Triangle subdivision
   - Worth subdividing triangles on solvers which are done on a
     triangle mesh?
** Conics for RHR triangular updates
** Adaptive mesh
   - Are there any conditions which we can use to determine how
     densely the domain needs to be sampled in order to achieve a
     desired accuracy?
   - If so, we could distribute points with the required density,
     compute a Delaunay triangulation, and then run an unstructured
     solver to compute a solution.
** A "one-point only" update
   - Imagine a point to be updated and the contour defined by the the
     boundary of its update neighborhood. Consider the value of the
     solution computed so far (including trial and far points). Since
     we consider far points, some of these values will be
     infinite. Choose an "appropriate" mapping which will send
     infinity to some finite value and preserve minima. Now
     periodically interpolate this function and find its global
     minimum. Do a one-point update from that point.
* Smart mesh
  - [X] Add solution info structure and visualize output
  - [ ] Look at Masha's program and plots
  - [ ] Try to figure out how smart grid works
    - Rough alg:
      1. Run normal fast marching method once, collect "solution information"
      2. Create a new graph whose initial vertex set consists of the
         original mesh vertices and whose edge set is empty
      3. For each vertex in the original mesh:
         - Connect the vertex to each of its "parent meshes" according
           to the solution information
         - If x and y are the parent vertices, add the point in [x, y]
           which lies on the characteristic entering the current
           solution vertex to the vertex set
  - Things to consider longer term:
    - [ ] Smart mesh refinement (Masha calls this "predictive
      meshing")
    - [ ] Recursive application of mesh refinement (i.e., if we can
      successfully refine once, is it possible to start with a very
      coarse grid and continually refine---is it possible this
      would save time?)
    - [ ] Actual predictive meshing (i.e., is there a way to avoid
      two passes?)
** Graph marcher
   - We want to implement a "graph marcher" to build our smart
     marchers on top of
   - [ ] Implement the basic graph marcher using a fairly generic
     graph data structure (just to get things working)
   - [-] Implement the basic 2D marcher using the graph marcher in
     order to 1) make sure that it works correctly, and 2) compare
     performance, to see what sort of performance hit is incurred
     (will also be useful for pub. plots later)
     - [X] Before we do this, we need to factor the parts of
       abstract_marcher that know about a cache of points (_S_cache)
       that are isotropically spaced (_h) into a separate class that
       basically just provides the S cache for MATLAB
       - [X] factor cache
       - [X] move h into marcher and marcher_3d
     - [ ] This is mostly done, but there is some error between the
       results obtained using the graph marcher and the basic
       marcher---fix this
     - [ ] Once the previous error is fixed, add a "planar
       neighborhood marcher" (i.e. sorting neighbors by angle) and
       reimplement test_graph_marcher in terms of it
** Planar graph marcher
   - We want to write a marcher on a planar graph (possible embedded
     in some higher dimensional ambient space)
   - The OLIM4 and OLIM8 methods provide a reasonable starting point
     for this---we want to generalize this
   - From OLIM4, we want to define a "first order" (not
     technically-speaking) method; and from OLIM8, we want to define a
     "second order" method
     - We should come up with better jargon for this than "order"
   - It looks like the way to generalize this is as follows:
     - In OLIM4, we first look at 2pt updates which occur in each
       triangle whose vertices are 1) both valid and 2) adjacent in
       the neighborhood. Following this, we perform 1pt updates from
       vertices which are not incident upon any of the 2pt update
       triangles
     - In OLIM8, we look at the same 2pt updates as in
       OLIM4. Additionally, we do 2pt updates for valid triangles
       whose vertices aren't adjacent, but instead are separated by
       one vertex; further, there is a condition depending on the
       in-between vertex which allows us to skip the update (e.g. in
       the case of OLIM8, we don't do these updates when both of the
       vertices are diagonal, since this triangle can be decomposed
       into two other triangles which have already been checked, so
       doing the update provides no additional information).
   - So, we can straightforwardly generalize OLIM4; we can also
     straightforwardly generalize OLIM8. Further, we can come up with
     higher "order" generalizations of this (every three, every
     four...).
   - How can we generalize this to "volumetric" neighborhoods? The
     first "order" case is easy; the second "order" case is less
     obvious.
* General
  - [ ] It would be good to conduct tests that don't just involve a
    single origin point. To this end:
    - [ ] Make it possible to initialize with a curve
      - [ ] Also need speed functions with analytic solutions for this case
    - [ ] Make it possible to initialize with a bunch of random points
      - [ ] Speed funcs w/ analytic solutions
    - It might be the case that Maria's optimized update rules only
      offer a speed-up in this "dense" case (at least in 2D)---this is
      just a hypothesis
  - [ ] Debug olim8_mp0l by fixing its performance on the linear (abs
    value) example---I believe it should give an exact result
  - [ ] Try doing the "ordered evaluations" (1pt, then 2pt, etc.) on
    my methods and see if there is any difference in the error
    - Is it possible to do a test on the values of s to see if the
      optimized/ordered evaluations would provide a correct answer? Is
      there a theorem relating to the Lipschitz constant of the
      function? It may depend on the mesh itself...
  - [ ] Make plot of size of heap during algorithms execution---see if
    it's possible to use a different data structure for parts of the
    algorithm to speed it up (like keeping a sorted array for small
    input sizes)
  - [ ] Try OLIM4 MP0C/L&MP1
  - [ ] For periodic Delaunay triangulations, see [[http://doc.cgal.org/latest/Periodic_2_triangulation_2/index.html][here]], but we should
    actually just use the Voronoi approach (MATLAB implementation [[http://people.sc.fsu.edu/~jburkardt/m_src/sphere_delaunay/sphere_delaunay.html][here]])
  - [X] Figure out source of error in marchers
    - [X] Make radial error plots, compare with Masha's
  - [ ] Add more sophisticated method for initializing boundary (see
    Masha's code)
  - [ ] Make it possible to specify boundary using sparse matrix of
    bools or doubles
  - [-] 3D marchers:
    - [X] Add a MEX interface for testing
    - [ ] Basic
      - [ ] Test speed and potentially optimize this---right now we
        just do all 1, 2, and 3 point updates, but some will not be
        necessary (depending on vertex incidence in neighborhood
        graph)
    - [ ] OLIM4
    - [ ] OLIM8 RHR
    - [ ] OLIM8 MP0C
    - [ ] OLIM8 MP0L
    - [ ] OLIM8 MP1
  - [X] Test different speed functions using Maria's analytic solutions
  - [X] Make up a couple neat analytic solutions
    - [X] Asymmetric one
    - [X] Cosine + abs one
  - [X] Add padding around the boundary to avoid complicating index calculations
  - [X] Make it possible to specify the origin to translate the speed function
  - [X] olim_8pt -> olim8
  - [ ] Add 'centered' keyword to center speed func
  - [X] Add (x0, y0) argument to MEX function
  - [X] Test mp methods using exact speed function solns
  - [X] Simplify MEX:
    - [X] parameter struct
    - [X] use a map for keyword parsing
  - [X] Get mp1 working
  - [X] Add framework to check errors from different analytic solutions
  - [ ] Compare speed of my implementation with Maria's implementation
  - [ ] Figure out how to add docstring for MEX function
  - [X] Implement midpoint method with 1oe speed function value
  - [X] Implement a basic rootfinder for midpoint rule updates (just
    using GSL for now)
    - Use values of speed functions from analytic solutions as test cases
  - [X] Derive updates for midpoint rule
    - [X] Diagonal
    - [X] Adjacent
  - [ ] Try more complicated root finders
    - [ ] Hybrid method
    - [ ] Secant method
    - [ ] Bairstow's method
  - [ ] Other quadrature rules
    - [ ] Trapezoid
    - [ ] Simpson's
    - [ ] Others?
  - [X] Make error/CPU time plots for comparison
  - [ ] See if it's possible to just solve the quartics involed in the
    midpoint rule OLIM exactly (although using GSL to solve the
    quartic is pretty g.d. fast)
  - [ ] Lookup table optimization for OLIM
    - [ ] OLIM4
    - [ ] OLIM6
    - [ ] OLIM8
    - [ ] OLIM26
  - [ ] Add a more robust initialization method for curves, etc.
  - [ ] For methods that degenerate when s = 1, come up with a way to
    issue a warning
    - [ ] Maybe when s0 = s1 we can just use the rhr update?
    - This may not be worth it
  - [ ] Boundary conditions
    - [ ] "Normal BCs"?
    - [ ] Periodic BCs
* Learning
  - [X] Reimplement 1oe fast marching method in C++ using Maria's
    simplified 1-point/2-point update
  - [X] Implement 8-point update
* Implementation
  - [ ] For olim6/18/26, add an intermediate template class with an
    integer template parameter which just implements
    get_valid_neighbors and stage_neighbors_impl (and maybe di, dj,
    dk...? this would be interesting)
  - [ ] Need to go through update functions and make sure we're
    clamping instead of "min"ing with infinity---this should ensure
    that skipping updates because their domain is a subset of another
    update is valid
  - [ ] Investigate using templates to avoid passing s_i arguments to
    update rules (e.g. for rhr and mp0 rules)
  - [ ] The 8pt and 4pt rule classes can be improved by turning them
    into abstract classes or template classes, where the individual
    methods just differ in the way they update T for each type of
    update
  - [ ] Remove extra padding from S matrix in getDefaultSMatrix in fmm.cpp
  - [ ] Add ctor for parameters in fmm.cpp
  - [ ] Do array error checking in fmm.cpp (in mexFunction)
  - [X] Use multiple inheritance for neumann and moore marchers
    - /ended up using template classes/
  - [ ] Figure out how to conditionally avoid using the _S_cache using
    function pointer
  - [X] Replace use of std::vector<double> for _S_cache with a double *
  - [X] Read Section 3 of "imm841.pdf" which talks about how to
    efficiently solve for the basic method. Try implementing this
  - [ ] Make sure layout of nodes agrees with MATLAB convention
  - [ ] Fix order of width and height are reversed w/r/t x0 and y0 in
    2d marcher
  - [-] Figure out how to speed up compile times:
    - [ ] http://lld.llvm.org: make sure we're using this on OS X
    - [ ] gold linker on Linux
    - [ ] Figure out how to use gcc/clang precompiled headers with CMake
    - [X] Replace use of boost::test with asserts (simpler and faster)
  - [X] olim8_util -> olim_util
  - [X] Consolidate di/dj/offsets in moore_marcher tree into a single
    static variable in moore_marcher
  - [X] fix "speed_func F" conflict (should be speed_func S or
    slowness_func F (the former is better))
  - [X] Add "keyword argument" style to MEX function
  - [ ] Python wrapper
  - [ ] Julia wrapper
  - [ ] Fix failing tests
  - [ ] Make sure to clean everything up in MATLAB
  - [ ] When you pass something like @(x, y) 1, MATLAB crashes. This
    is because MATLAB doesn't automatically broadcast the 1 to a
    matrix. Need to handle this case and do error checking when the
    matrix that is returned is the incorrect size. (i.e. handle
    function handles that aren't vectorized)
  - [ ] Make sure a regular function (not a handle) can be passed
  - [ ] Make the MEX function able to take a double matrix for the
    boundary matrix
  - [ ] Use numeric_limits to check all static casts

# Local Variables:
# indent-tabs-mode: nil
# End:

* Tasks
  - [X] Test different speed functions using Maria's analytic solutions
  - [X] Make up a couple neat analytic solutions
  - [ ] Add padding around the boundary to avoid complicating index calculations
  - [ ] Make it possible to specify the origin to translate the speed function
  - [ ] Make it possible to use a matrix instead of a speed or slowness function
  - [ ] Test mp methods using exact speed function solns
  - [ ] Add framework to check errors from different analytic solutions
  - [ ] Compare speed of my implementation with Maria's implementation
  - [X] Implement midpoint method with 1oe speed function value
  - [X] Implement a basic rootfinder for midpoint rule updates (just
    using GSL for now)
	- Use values of speed functions from analytic solutions as test cases
  - [X] Derive updates for midpoint rule
	- [X] Diagonal
	- [X] Adjacent
  - [ ] Try more complicated root finders
	- [ ] Hybrid method
	- [ ] Secant method
	- [ ] Bairstow's method
  - [ ] Other quadrature rules
	- [ ] Trapezoid
	- [ ] Simpson's
	- [ ] Others?
  - [ ] Make error/CPU time plots for comparison
  - [ ] See if it's possible to just solve the quartics involed in the
    midpoint rule OLIM exactly
  - [ ] Lookup table optimization for OLIM
  - [ ] Add a more robust initialization method for curves, etc.
  - [ ] For methods that degenerate when s = 1, come up with a way to
    issue a warning
	- [ ] Maybe when s0 = s1 we can just use the rhr update?
* Learning
  - [X] Reimplement 1oe fast marching method in C++ using Maria's
    simplified 1-point/2-point update
  - [X] Implement 8-point update
* Implementation
  - [ ] fix "speed_func F" conflict (should be speed_func S or
    slowness_func F (the former is better))
  - [X] Add "keyword argument" style to MEX function
  - [ ] Python wrapper
  - [ ] Julia wrapper

* Tasks
  - [X] Test different speed functions using Maria's analytic solutions
  - [-] Make up a couple neat analytic solutions
	- [ ] Asymmetric one
	- [X] Cosine + abs one
  - [X] Add padding around the boundary to avoid complicating index calculations
  - [X] Make it possible to specify the origin to translate the speed function
  - [X] olim_8pt -> olim8
  - [ ] Add 'centered' keyword to center speed func
  - [X] Add (x0, y0) argument to MEX function
  - [X] Test mp methods using exact speed function solns
  - [X] Simplify MEX:
	- [X] parameter struct
	- [X] use a map for keyword parsing
  - [ ] Get mp1 working
  - [X] Add framework to check errors from different analytic solutions
  - [ ] Compare speed of my implementation with Maria's implementation
  - [ ] Figure out how to add docstring for MEX function
  - [X] Implement midpoint method with 1oe speed function value
  - [X] Implement a basic rootfinder for midpoint rule updates (just
    using GSL for now)
	- Use values of speed functions from analytic solutions as test cases
  - [X] Derive updates for midpoint rule
	- [X] Diagonal
	- [X] Adjacent
  - [ ] Try more complicated root finders
	- [ ] Hybrid method
	- [ ] Secant method
	- [ ] Bairstow's method
  - [ ] Other quadrature rules
	- [ ] Trapezoid
	- [ ] Simpson's
	- [ ] Others?
  - [X] Make error/CPU time plots for comparison
  - [ ] See if it's possible to just solve the quartics involed in the
    midpoint rule OLIM exactly (although using GSL to solve the
    quartic is pretty g.d. fast)
  - [ ] Lookup table optimization for OLIM
  - [ ] Add a more robust initialization method for curves, etc.
  - [ ] For methods that degenerate when s = 1, come up with a way to
    issue a warning
	- [ ] Maybe when s0 = s1 we can just use the rhr update?
  - [ ] Boundary conditions
	- [ ] "Normal BCs"?
	- [ ] Periodic BCs
* Learning
  - [X] Reimplement 1oe fast marching method in C++ using Maria's
    simplified 1-point/2-point update
  - [X] Implement 8-point update
* Implementation
  - [ ] Consolidate di/dj/offsets in moore_marcher tree into a single
    static variable in moore_marcher
  - [X] fix "speed_func F" conflict (should be speed_func S or
    slowness_func F (the former is better))
  - [X] Add "keyword argument" style to MEX function
  - [ ] Python wrapper
  - [ ] Julia wrapper
  - [ ] Adding padding for BCs seemed to fix issue---but we didn't
    have to explicitly avoid updating boundary cells. Is this because
    there are no problems if we don't add any boundary points to the
    padding?
  - [ ] Use boost::test for all tests (the fancy test macro in Boost.Test)
  - [ ] Make sure to clean everything up in MATLAB
  - [ ] When you pass something like @(x, y) 1, MATLAB crashes. This
    is because MATLAB doesn't automatically broadcast the 1 to a
    matrix. Need to handle this case and do error checking when the
    matrix that is returned is the incorrect size.
  - [ ] Check and see what happens when a function handle that isn't
    vectorized is passed...
  - [ ] Make the MEX function able to take a double matrix for the
    boundary matrix
  - [ ] Use numeric_limits to check all static casts
  - [ ] Look into using C++ heap stuff instead of my own...

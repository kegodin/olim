* Smart mesh
  - [X] Add solution info structure and visualize output
  - [ ] Look at Masha's program and plots
  - [ ] Try to figure out how smart grid works
    - Rough alg:
      1. Run normal fast marching method once, collect "solution information"
      2. Create a new graph whose initial vertex set consists of the
         original mesh vertices and whose edge set is empty
      3. For each vertex in the original mesh:
         - Connect the vertex to each of its "parent meshes" according
           to the solution information
         - If x and y are the parent vertices, add the point in [x, y]
           which lies on the characteristic entering the current
           solution vertex to the vertex set
  - Things to consider longer term:
    - [ ] Smart mesh refinement (Masha calls this "predictive
      meshing")
    - [ ] Recursive application of mesh refinement (i.e., if we can
      successfully refine once, is it possible to start with a very
      coarse grid and continually refine---is it possible this
      would save time?)
    - [ ] Actual predictive meshing (i.e., is there a way to avoid
      two passes?)
** Graph marcher
   - We want to implement a "graph marcher" to build our smart
     marchers on top of
   - [ ] Implement the basic graph marcher using a fairly generic
     graph data structure (just to get things working)
   - [-] Implement the basic 2D marcher using the graph marcher in
     order to 1) make sure that it works correctly, and 2) compare
     performance, to see what sort of performance hit is incurred
     (will also be useful for pub. plots later)
     - [X] Before we do this, we need to factor the parts of
       abstract_marcher that know about a cache of points (_S_cache)
       that are isotropically spaced (_h) into a separate class that
       basically just provides the S cache for MATLAB
       - [X] factor cache
       - [X] move h into marcher and marcher_3d
     - [ ] This is mostly done, but there is some error between the
       results obtained using the graph marcher and the basic
       marcher---fix this
     - [ ] Once the previous error is fixed, add a "planar
       neighborhood marcher" (i.e. sorting neighbors by angle) and
       reimplement test_graph_marcher in terms of it
** Planar graph marcher
   - We want to write a marcher on a planar graph (possible embedded
     in some higher dimensional ambient space)
   - The OLIM4 and OLIM8 methods provide a reasonable starting point
     for this---we want to generalize this
   - From OLIM4, we want to define a "first order" (not
     technically-speaking) method; and from OLIM8, we want to define a
     "second order" method
     - We should come up with better jargon for this than "order"
   - It looks like the way to generalize this is as follows:
     - In OLIM4, we first look at 2pt updates which occur in each
       triangle whose vertices are 1) both valid and 2) adjacent in
       the neighborhood. Following this, we perform 1pt updates from
       vertices which are not incident upon any of the 2pt update
       triangles
     - In OLIM8, we look at the same 2pt updates as in
       OLIM4. Additionally, we do 2pt updates for valid triangles
       whose vertices aren't adjacent, but instead are separated by
       one vertex; further, there is a condition depending on the
       in-between vertex which allows us to skip the update (e.g. in
       the case of OLIM8, we don't do these updates when both of the
       vertices are diagonal, since this triangle can be decomposed
       into two other triangles which have already been checked, so
       doing the update provides no additional information).
   - So, we can straightforwardly generalize OLIM4; we can also
     straightforwardly generalize OLIM8. Further, we can come up with
     higher "order" generalizations of this (every three, every
     four...).
   - How can we generalize this to "volumetric" neighborhoods? The
     first "order" case is easy; the second "order" case is less
     obvious.
* General
  - [ ] Make plot of size of heap during algorithms execution---see if
    it's possible to use a different data structure for parts of the
    algorithm to speed it up (like keeping a sorted array for small
    input sizes)
  - [ ] For periodic Delaunay triangulations, see [[http://doc.cgal.org/latest/Periodic_2_triangulation_2/index.html][here]], but we should
    actually just use the Voronoi approach (MATLAB implementation [[http://people.sc.fsu.edu/~jburkardt/m_src/sphere_delaunay/sphere_delaunay.html][here]])
  - [X] Figure out source of error in marchers
    - [X] Make radial error plots, compare with Masha's
  - [ ] Add more sophisticated method for initializing boundary (see
    Masha's code)
  - [ ] Make it possible to specify boundary using sparse matrix of
    bools or doubles
  - [-] 3D marchers:
    - [X] Add a MEX interface for testing
    - [X] Basic
      - [ ] Test speed and potentially optimize this---right now we
        just do all 1, 2, and 3 point updates, but some will not be
        necessary (depending on vertex incidence in neighborhood
        graph)
    - [ ] OLIM4
    - [ ] OLIM8 RHR
    - [ ] OLIM8 MP0
    - [ ] OLIM8 MP1
  - [X] Test different speed functions using Maria's analytic solutions
  - [X] Make up a couple neat analytic solutions
    - [X] Asymmetric one
    - [X] Cosine + abs one
  - [X] Add padding around the boundary to avoid complicating index calculations
  - [X] Make it possible to specify the origin to translate the speed function
  - [X] olim_8pt -> olim8
  - [ ] Add 'centered' keyword to center speed func
  - [X] Add (x0, y0) argument to MEX function
  - [X] Test mp methods using exact speed function solns
  - [X] Simplify MEX:
    - [X] parameter struct
    - [X] use a map for keyword parsing
  - [X] Get mp1 working
  - [X] Add framework to check errors from different analytic solutions
  - [ ] Compare speed of my implementation with Maria's implementation
  - [ ] Figure out how to add docstring for MEX function
  - [X] Implement midpoint method with 1oe speed function value
  - [X] Implement a basic rootfinder for midpoint rule updates (just
    using GSL for now)
    - Use values of speed functions from analytic solutions as test cases
  - [X] Derive updates for midpoint rule
    - [X] Diagonal
    - [X] Adjacent
  - [ ] Try more complicated root finders
    - [ ] Hybrid method
    - [ ] Secant method
    - [ ] Bairstow's method
  - [ ] Other quadrature rules
    - [ ] Trapezoid
    - [ ] Simpson's
    - [ ] Others?
  - [X] Make error/CPU time plots for comparison
  - [ ] See if it's possible to just solve the quartics involed in the
    midpoint rule OLIM exactly (although using GSL to solve the
    quartic is pretty g.d. fast)
  - [ ] Lookup table optimization for OLIM
    - [ ] OLIM4
    - [ ] OLIM6
    - [ ] OLIM8
    - [ ] OLIM26
  - [ ] Add a more robust initialization method for curves, etc.
  - [ ] For methods that degenerate when s = 1, come up with a way to
    issue a warning
    - [ ] Maybe when s0 = s1 we can just use the rhr update?
    - This may not be worth it
  - [ ] Boundary conditions
    - [ ] "Normal BCs"?
    - [ ] Periodic BCs
* Learning
  - [X] Reimplement 1oe fast marching method in C++ using Maria's
    simplified 1-point/2-point update
  - [X] Implement 8-point update
* Implementation
  - [ ] Remove extra padding from S matrix in getDefaultSMatrix in fmm.cpp
  - [ ] Add ctor for parameters in fmm.cpp
  - [ ] Do array error checking in fmm.cpp (in mexFunction)
  - [X] Use multiple inheritance for neumann and moore marchers
    - /ended up using template classes/
  - [ ] Figure out how to conditionally avoid using the _S_cache using
    function pointer
  - [X] Replace use of std::vector<double> for _S_cache with a double *
  - [X] Read Section 3 of "imm841.pdf" which talks about how to
    efficiently solve for the basic method. Try implementing this
  - [ ] Make sure layout of nodes agrees with MATLAB convention
  - [ ] Fix order of width and height are reversed w/r/t x0 and y0 in
    2d marcher
  - [-] Figure out how to speed up compile times:
    - [ ] http://lld.llvm.org: make sure we're using this on OS X
    - [ ] gold linker on Linux
    - [ ] Figure out how to use gcc/clang precompiled headers with CMake
    - [X] Replace use of boost::test with asserts (simpler and faster)
  - [X] olim8_util -> olim_util
  - [X] Consolidate di/dj/offsets in moore_marcher tree into a single
    static variable in moore_marcher
  - [X] fix "speed_func F" conflict (should be speed_func S or
    slowness_func F (the former is better))
  - [X] Add "keyword argument" style to MEX function
  - [ ] Python wrapper
  - [ ] Julia wrapper
  - [ ] Fix failing tests
  - [ ] Make sure to clean everything up in MATLAB
  - [ ] When you pass something like @(x, y) 1, MATLAB crashes. This
    is because MATLAB doesn't automatically broadcast the 1 to a
    matrix. Need to handle this case and do error checking when the
    matrix that is returned is the incorrect size. (i.e. handle
    function handles that aren't vectorized)
  - [ ] Make sure a regular function (not a handle) can be passed
  - [ ] Make the MEX function able to take a double matrix for the
    boundary matrix
  - [ ] Use numeric_limits to check all static casts

# Local Variables:
# indent-tabs-mode: nil
# End:

* Tasks
  - [X] Test different speed functions using Maria's analytic solutions
  - [ ] Make up a couple neat analytic solutions
  - [ ] Make it possible to use a matrix instead of a speed or slowness function
  - [ ] Make it possible to specify the origin to translate the speed function
  - [ ] Add framework to check errors from different analytic solutions
  - [ ] Compare speed of my implementation with Maria's implementation
  - [ ] Implement midpoint method with 1oe speed function value
  - [ ] Implement a basic rootfinder for midpoint rule updates
	- Use values of speed functions from analytic solutions as test cases
  - [ ] Derive updates for midpoint rule
	- [ ] Diagonal
	- [ ] Adjacent
  - [ ] Try more complicated root finders
	- [ ] Hybrid method
	- [ ] Secant method
	- [ ] Bairstow's method
  - [ ] Other quadrature rules
	- [ ] Trapezoid
	- [ ] Simpson's
	- [ ] Others?
  - [ ] Make error/CPU time plots for comparison
  - [ ] See if it's possible to just solve the quartics involed in the
    midpoint rule OLIM exactly
  - [ ] Lookup table optimization for OLIM
  - [ ] Add a more robust initialization method for curves, etc.
* Learning
  - [X] Reimplement 1oe fast marching method in C++ using Maria's
    simplified 1-point/2-point update
  - [X] Implement 8-point update
* Implementation
  - [ ] Make sure to reset the cache (in fast_marcher::F) when necessary
  - [ ] Add "keyword argument" style to MEX function
  - [ ] Python wrapper
  - [ ] Julia wrapper

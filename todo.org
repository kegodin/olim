* Smart mesh
  - [ ] Add solution info structure and visualize output
  - [ ] Look at Masha's program and plots
  - [ ] Try to figure out how smart grid works
  - Things to consider longer term:
    - [ ] Smart mesh refinement (Masha calls this "predictive
      meshing")
    - [ ] Recursive application of mesh refinement (i.e., if we can
      successfully refine once, is it possible to start with a very
      coarse grid and continually refine---is it possible this
      would save time?)
    - [ ] Actual predictive meshing (i.e., is there a way to avoid
      two passes?)
* General
  - [X] Figure out source of error in marchers
    - [X] Make radial error plots, compare with Masha's
  - [ ] Make it possible to specify boundary using sparse matrix of
    bools or doubles
  - [ ] 3D marchers:
    - [ ] Basic
      - [ ] OLIM4
      - [ ] OLIM8 RHR
      - [ ] OLIM8 MP0
      - [ ] OLIM8 MP1
  - [X] Test different speed functions using Maria's analytic solutions
  - [X] Make up a couple neat analytic solutions
    - [X] Asymmetric one
    - [X] Cosine + abs one
  - [X] Add padding around the boundary to avoid complicating index calculations
  - [X] Make it possible to specify the origin to translate the speed function
  - [X] olim_8pt -> olim8
  - [ ] Add 'centered' keyword to center speed func
  - [X] Add (x0, y0) argument to MEX function
  - [X] Test mp methods using exact speed function solns
  - [X] Simplify MEX:
    - [X] parameter struct
    - [X] use a map for keyword parsing
  - [X] Get mp1 working
  - [X] Add framework to check errors from different analytic solutions
  - [ ] Compare speed of my implementation with Maria's implementation
  - [ ] Figure out how to add docstring for MEX function
  - [X] Implement midpoint method with 1oe speed function value
  - [X] Implement a basic rootfinder for midpoint rule updates (just
    using GSL for now)
    - Use values of speed functions from analytic solutions as test cases
  - [X] Derive updates for midpoint rule
    - [X] Diagonal
    - [X] Adjacent
  - [ ] Try more complicated root finders
    - [ ] Hybrid method
    - [ ] Secant method
    - [ ] Bairstow's method
  - [ ] Other quadrature rules
    - [ ] Trapezoid
    - [ ] Simpson's
    - [ ] Others?
  - [X] Make error/CPU time plots for comparison
  - [ ] See if it's possible to just solve the quartics involed in the
    midpoint rule OLIM exactly (although using GSL to solve the
    quartic is pretty g.d. fast)
  - [ ] Lookup table optimization for OLIM
  - [ ] Add a more robust initialization method for curves, etc.
  - [ ] For methods that degenerate when s = 1, come up with a way to
    issue a warning
    - [ ] Maybe when s0 = s1 we can just use the rhr update?
    - This may not be worth it
  - [ ] Boundary conditions
    - [ ] "Normal BCs"?
    - [ ] Periodic BCs
* Learning
  - [X] Reimplement 1oe fast marching method in C++ using Maria's
    simplified 1-point/2-point update
  - [X] Implement 8-point update
* Implementation
  - [ ] Use multiple inheritance for neumann and moore marchers
  - [ ] Figure out how to conditionally avoid using the _S_cache by
    conditionally setting function pointer
  - [ ] See which protected member functions in fast_marcher(_3d) can
    be made private
  - [X] Replace use of std::vector<double> for _S_cache with a double *
  - [X] Read Section 3 of "imm841.pdf" which talks about how to
    efficiently solve for the basic method. Try implementing this
  - [ ] Make sure layout of nodes agrees with MATLAB convention
  - [ ] Fix order of width and height are reversed w/r/t x0 and y0 in
    2d marcher
  - [ ] Figure out how to speed up compile times:
    - [ ] Figure out how to use gcc/clang precompiled headers with CMake
    - [X] Replace use of boost::test with asserts (simpler and faster)
  - [X] olim8_util -> olim_util
  - [X] Consolidate di/dj/offsets in moore_marcher tree into a single
    static variable in moore_marcher
  - [X] fix "speed_func F" conflict (should be speed_func S or
    slowness_func F (the former is better))
  - [X] Add "keyword argument" style to MEX function
  - [ ] Python wrapper
  - [ ] Julia wrapper
  - [ ] Fix failing tests
  - [ ] Make sure to clean everything up in MATLAB
  - [ ] When you pass something like @(x, y) 1, MATLAB crashes. This
    is because MATLAB doesn't automatically broadcast the 1 to a
    matrix. Need to handle this case and do error checking when the
    matrix that is returned is the incorrect size. (i.e. handle
    function handles that aren't vectorized)
  - [ ] Make sure a regular function (not a handle) can be passed
  - [ ] Make the MEX function able to take a double matrix for the
    boundary matrix
  - [ ] Use numeric_limits to check all static casts

# Local Variables:
# indent-tabs-mode: nil
# End:

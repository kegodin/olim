* Masha's todo list
   1. "Suppose slowness is smooth or Lipschitz continuous. Show that
      than one can use hierarchical update rules for saving CPU time."
   2. "3D: hierarchical update vs complete update"
   3. "Smart mesh"
   4. "Smart mesh for 6 point update"
   5. "Predictive smart mesh"
* Ideas
** Regular mesh triangular updates
   - There are two types of "regular mesh triangular updates" (RMTUs)
     in 2D and three in 3D. It's easy to identify these with ways of
     choosing simplices embedded in a hybercube based on the Hamming
     norms of the vertices of the simplices. Are there n RMTUs in n
     dimensions? Is there an automatic procedure to extract them?
** Conics for RHR triangular updates
** Adaptive mesh
   - Are there any conditions which we can use to determine how
     densely the domain needs to be sampled in order to achieve a
     desired accuracy?
   - If so, we could distribute points with the required density,
     compute a Delaunay triangulation, and then run an unstructured
     solver to compute a solution.
** A "one-point only" update
   - Imagine a point to be updated and the contour defined by the the
     boundary of its update neighborhood. Consider the value of the
     solution computed so far (including trial and far points). Since
     we consider far points, some of these values will be
     infinite. Choose an "appropriate" mapping which will send
     infinity to some finite value and preserve minima. Now
     periodically interpolate this function and find its global
     minimum. Do a one-point update from that point.
* Smart mesh
  - [X] Add solution info structure and visualize output
  - [ ] Look at Masha's program and plots
  - [ ] Try to figure out how smart grid works
    - Rough alg:
      1. Run normal fast marching method once, collect "solution information"
      2. Create a new graph whose initial vertex set consists of the
         original mesh vertices and whose edge set is empty
      3. For each vertex in the original mesh:
         - Connect the vertex to each of its "parent meshes" according
           to the solution information
         - If x and y are the parent vertices, add the point in [x, y]
           which lies on the characteristic entering the current
           solution vertex to the vertex set
  - Things to consider longer term:
    - [ ] Smart mesh refinement (Masha calls this "predictive
      meshing")
    - [ ] Recursive application of mesh refinement (i.e., if we can
      successfully refine once, is it possible to start with a very
      coarse grid and continually refine---is it possible this
      would save time?)
    - [ ] Actual predictive meshing (i.e., is there a way to avoid
      two passes?)
** Graph marcher
   - We want to implement a "graph marcher" to build our smart
     marchers on top of
   - [ ] Implement the basic graph marcher using a fairly generic
     graph data structure (just to get things working)
   - [-] Implement the basic 2D marcher using the graph marcher in
     order to 1) make sure that it works correctly, and 2) compare
     performance, to see what sort of performance hit is incurred
     (will also be useful for pub. plots later)
     - [X] Before we do this, we need to factor the parts of
       abstract_marcher that know about a cache of points (_S_cache)
       that are isotropically spaced (_h) into a separate class that
       basically just provides the S cache for MATLAB
       - [X] factor cache
       - [X] move h into marcher and marcher_3d
     - [ ] This is mostly done, but there is some error between the
       results obtained using the graph marcher and the basic
       marcher---fix this
     - [ ] Once the previous error is fixed, add a "planar
       neighborhood marcher" (i.e. sorting neighbors by angle) and
       reimplement test_graph_marcher in terms of it
** Planar graph marcher
   - We want to write a marcher on a planar graph (possible embedded
     in some higher dimensional ambient space)
   - The OLIM4 and OLIM8 methods provide a reasonable starting point
     for this---we want to generalize this
   - From OLIM4, we want to define a "first order" (not
     technically-speaking) method; and from OLIM8, we want to define a
     "second order" method
     - We should come up with better jargon for this than "order"
   - It looks like the way to generalize this is as follows:
     - In OLIM4, we first look at 2pt updates which occur in each
       triangle whose vertices are 1) both valid and 2) adjacent in
       the neighborhood. Following this, we perform 1pt updates from
       vertices which are not incident upon any of the 2pt update
       triangles
     - In OLIM8, we look at the same 2pt updates as in
       OLIM4. Additionally, we do 2pt updates for valid triangles
       whose vertices aren't adjacent, but instead are separated by
       one vertex; further, there is a condition depending on the
       in-between vertex which allows us to skip the update (e.g. in
       the case of OLIM8, we don't do these updates when both of the
       vertices are diagonal, since this triangle can be decomposed
       into two other triangles which have already been checked, so
       doing the update provides no additional information).
   - So, we can straightforwardly generalize OLIM4; we can also
     straightforwardly generalize OLIM8. Further, we can come up with
     higher "order" generalizations of this (every three, every
     four...).
   - How can we generalize this to "volumetric" neighborhoods? The
     first "order" case is easy; the second "order" case is less
     obvious.
* General
  - [ ] It would be good to conduct tests that don't just involve a
    single origin point. To this end:
    - [ ] Make it possible to initialize with a curve
      - [ ] Also need speed functions with analytic solutions for this case
    - [ ] Make it possible to initialize with a bunch of random points
      - [ ] Speed funcs w/ analytic solutions
    - It might be the case that Maria's optimized update rules only
      offer a speed-up in this "dense" case (at least in 2D)---this is
      just a hypothesis
  - [ ] Debug olim8_mp0l by fixing its performance on the linear (abs
    value) example---I believe it should give an exact result
  - [ ] Try doing the "ordered evaluations" (1pt, then 2pt, etc.) on
    my methods and see if there is any difference in the error
    - Is it possible to do a test on the values of s to see if the
      optimized/ordered evaluations would provide a correct answer? Is
      there a theorem relating to the Lipschitz constant of the
      function? It may depend on the mesh itself...
  - [ ] Make plot of size of heap during algorithms execution---see if
    it's possible to use a different data structure for parts of the
    algorithm to speed it up (like keeping a sorted array for small
    input sizes)
  - [ ] Try OLIM4 MP0C/L&MP1
  - [ ] For periodic Delaunay triangulations, see [[http://doc.cgal.org/latest/Periodic_2_triangulation_2/index.html][here]], but we should
    actually just use the Voronoi approach (MATLAB implementation [[http://people.sc.fsu.edu/~jburkardt/m_src/sphere_delaunay/sphere_delaunay.html][here]])
  - [X] Figure out source of error in marchers
    - [X] Make radial error plots, compare with Masha's
  - [ ] Add more sophisticated method for initializing boundary (see
    Masha's code)
  - [ ] Make it possible to specify boundary using sparse matrix of
    bools or doubles
  - [-] 3D marchers:
    - [X] Add a MEX interface for testing
    - [ ] Basic
      - [ ] Test speed and potentially optimize this---right now we
        just do all 1, 2, and 3 point updates, but some will not be
        necessary (depending on vertex incidence in neighborhood
        graph)
    - [ ] OLIM4
    - [ ] OLIM8 RHR
    - [ ] OLIM8 MP0C
    - [ ] OLIM8 MP0L
    - [ ] OLIM8 MP1
  - [X] Test different speed functions using Maria's analytic solutions
  - [X] Make up a couple neat analytic solutions
    - [X] Asymmetric one
    - [X] Cosine + abs one
  - [X] Add padding around the boundary to avoid complicating index calculations
  - [X] Make it possible to specify the origin to translate the speed function
  - [X] olim_8pt -> olim8
  - [ ] Add 'centered' keyword to center speed func
  - [X] Add (x0, y0) argument to MEX function
  - [X] Test mp methods using exact speed function solns
  - [X] Simplify MEX:
    - [X] parameter struct
    - [X] use a map for keyword parsing
  - [X] Get mp1 working
  - [X] Add framework to check errors from different analytic solutions
  - [ ] Compare speed of my implementation with Maria's implementation
  - [ ] Figure out how to add docstring for MEX function
  - [X] Implement midpoint method with 1oe speed function value
  - [X] Implement a basic rootfinder for midpoint rule updates (just
    using GSL for now)
    - Use values of speed functions from analytic solutions as test cases
  - [X] Derive updates for midpoint rule
    - [X] Diagonal
    - [X] Adjacent
  - [ ] Try more complicated root finders
    - [ ] Hybrid method
    - [ ] Secant method
    - [ ] Bairstow's method
  - [ ] Other quadrature rules
    - [ ] Trapezoid
    - [ ] Simpson's
    - [ ] Others?
  - [X] Make error/CPU time plots for comparison
  - [ ] See if it's possible to just solve the quartics involed in the
    midpoint rule OLIM exactly (although using GSL to solve the
    quartic is pretty g.d. fast)
  - [ ] Lookup table optimization for OLIM
    - [ ] OLIM4
    - [ ] OLIM6
    - [ ] OLIM8
    - [ ] OLIM26
  - [ ] Add a more robust initialization method for curves, etc.
  - [ ] For methods that degenerate when s = 1, come up with a way to
    issue a warning
    - [ ] Maybe when s0 = s1 we can just use the rhr update?
    - This may not be worth it
  - [ ] Boundary conditions
    - [ ] "Normal BCs"?
    - [ ] Periodic BCs
* Learning
  - [X] Reimplement 1oe fast marching method in C++ using Maria's
    simplified 1-point/2-point update
  - [X] Implement 8-point update
* Implementation
  - [ ] The 8pt and 4pt rule classes can be improved by turning them
    into abstract classes or template classes, where the individual
    methods just differ in the way they update T for each type of
    update
  - [ ] Remove extra padding from S matrix in getDefaultSMatrix in fmm.cpp
  - [ ] Add ctor for parameters in fmm.cpp
  - [ ] Do array error checking in fmm.cpp (in mexFunction)
  - [X] Use multiple inheritance for neumann and moore marchers
    - /ended up using template classes/
  - [ ] Figure out how to conditionally avoid using the _S_cache using
    function pointer
  - [X] Replace use of std::vector<double> for _S_cache with a double *
  - [X] Read Section 3 of "imm841.pdf" which talks about how to
    efficiently solve for the basic method. Try implementing this
  - [ ] Make sure layout of nodes agrees with MATLAB convention
  - [ ] Fix order of width and height are reversed w/r/t x0 and y0 in
    2d marcher
  - [-] Figure out how to speed up compile times:
    - [ ] http://lld.llvm.org: make sure we're using this on OS X
    - [ ] gold linker on Linux
    - [ ] Figure out how to use gcc/clang precompiled headers with CMake
    - [X] Replace use of boost::test with asserts (simpler and faster)
  - [X] olim8_util -> olim_util
  - [X] Consolidate di/dj/offsets in moore_marcher tree into a single
    static variable in moore_marcher
  - [X] fix "speed_func F" conflict (should be speed_func S or
    slowness_func F (the former is better))
  - [X] Add "keyword argument" style to MEX function
  - [ ] Python wrapper
  - [ ] Julia wrapper
  - [ ] Fix failing tests
  - [ ] Make sure to clean everything up in MATLAB
  - [ ] When you pass something like @(x, y) 1, MATLAB crashes. This
    is because MATLAB doesn't automatically broadcast the 1 to a
    matrix. Need to handle this case and do error checking when the
    matrix that is returned is the incorrect size. (i.e. handle
    function handles that aren't vectorized)
  - [ ] Make sure a regular function (not a handle) can be passed
  - [ ] Make the MEX function able to take a double matrix for the
    boundary matrix
  - [ ] Use numeric_limits to check all static casts

# Local Variables:
# indent-tabs-mode: nil
# End:
